//helper functions work together to score a boggle board using
//the text file, 'EnglishWords.txt'
#include <iostream>    // for cout, endl
#include <string>      // for string class
#include "recursion.h"
#include "gridlocation.h"
#include "grid.h"
#include "set.h"
#include "lexicon.h"
#include "testing/SimpleTest.h"
using namespace std;

//this function takes in a string and returns an int
//it returns 0 for strings of lengths less than 3
//for strings of lengths greater than 3, it returns 3 subtracted
//from the length
int points(string str) {
    if (str.length() <= 3){
        return 0;
    }
    else {
        return str.length() - 3;
    }

}


//this function takes in a Grid of characters, a GridLocation, and a set of visited GridLocations
//it generates 8 possible grid locations and then adds these possible neighbors to a set of neighbors
//if it is in bounds, not an empty space, and has not been visited before
Set<GridLocation> generateNeighbors(Grid<char>& board, GridLocation cur, Set<GridLocation>& visited) {
    Set<GridLocation> neighbors;
    Set<GridLocation> possibleNeighbors;
    for (int i = -1; i < 2; i++){ //adds 8 locations to possibleNeighbors: N, S, E, W, NE, NW, SE, SW
        for(int j = -1; j < 2; j++){
            if (!(i == 0 && j == 0)){
                possibleNeighbors.add(GridLocation(cur.row + i, cur.col + j));
            }

        }
    }

    for (GridLocation possibleNeighbor : possibleNeighbors){ //if the niehgbor is in bounds, is not a space, and has not been visited
        if (board.inBounds(possibleNeighbor) && (board[possibleNeighbor] != '_') && (!visited.contains(possibleNeighbor))) {
                neighbors.add(possibleNeighbor);
        }

    }
    return neighbors;
}

//this function takes a board, lexicon, GridLocation, word, set of all words, and set of visited locations
//and returns an integer representing the total score attained by words stemming from that one location
//for example, if the GridLocation given leads to "apple" and "apes", then it will return the points earned by both of
//those words as an integer
int scoreBoardHelper(Grid<char>&board, Lexicon& lex, GridLocation current, string word, Set<string>& allWords, Set<GridLocation>& visited){
    int pointTotal = 0;
    if (lex.contains(word) && !allWords.contains(word)){ //we found a word, and it's a unique word we haven't found before
        allWords.add(word);
        return points(word) + scoreBoardHelper(board, lex, current, word, allWords, visited); //call scoreBoardHelper again in case another word stems from it
    }                                                                                          //for example, "LIME" and "LIMES"
    else if (!lex.containsPrefix(word) && (word.length() >= 2)){ //prunes out paths we know will not lead to a word
        return 0;
    }

    Set<GridLocation> neighbors = generateNeighbors(board, current, visited);

    if (word == ""){
        word = board[current];
        visited.add(current);
    }
    for (GridLocation neighbor: neighbors) {
        word += board[neighbor];
        visited.add(neighbor);

        pointTotal += scoreBoardHelper(board, lex, neighbor, word, allWords, visited); //point total for each neighbor is added

        word = word.substr(0, word.length() - 1); //undo step
        visited.remove(neighbor);

    }
    visited.remove(current); //undo step


    return pointTotal;
}

//this function uses the helper function in order to score a boggle board
//it takes in a grid of characters and the lexicon
//it iterates through each non-space location on the boggle board and tallys
//up the score generated by each spot on the board. this function combines iteration
//with the scoreBoardHelper function's recursion.
int scoreBoard(Grid<char>& board, Lexicon& lex) {
    string word = "";
    Set<string> allWords;
    Set<GridLocation> visited;
    int returnValue = 0;

    for (int i = 0; i < board.height(); i++){
        for (int j = 0; j < board.width(); j++){
            if (board[i][j] != '_'){
                GridLocation location;
                location.row = i;
                location.col = j;
                returnValue += scoreBoardHelper(board, lex, location, word, allWords, visited);
            }
        }
    }
    return returnValue;

}

/* * * * * * Test Cases * * * * * */

/* Test helper function to return shared copy of Lexicon. Use to
 * avoid (expensive) re-load of word list on each test case. */
Lexicon& sharedLexicon() {
    static Lexicon lex("res/EnglishWords.txt");
    return lex;
}

PROVIDED_TEST("Load shared Lexicon, confirm number of words") {
    Lexicon lex = sharedLexicon();
    EXPECT_EQUAL(lex.size(), 127145);
}

PROVIDED_TEST("Test point scoring") {
    EXPECT_EQUAL(points("and"), 0);
    EXPECT_EQUAL(points("quad"), 1);
    EXPECT_EQUAL(points("quint"), 2);
    EXPECT_EQUAL(points("sextet"), 3);
    EXPECT_EQUAL(points("seventh"), 4);
    EXPECT_EQUAL(points("supercomputer"), 10);
}

PROVIDED_TEST("Test scoreBoard, board contains no words, score of zero") {
    Grid<char> board = {{'B','C','D','F'}, //no vowels, no words
                        {'G','H','J','K'},
                        {'L','M','N','P'},
                        {'Q','R','S','T'}};
    EXPECT_EQUAL(scoreBoard(board, sharedLexicon()), 0);
}

PROVIDED_TEST("Test scoreBoard, board contains one word, score of 1") {
    Grid<char> board = {{'C','_','_','_'},
                        {'Z','_','_','_'},
                        {'_','A','_','_'},
                        {'_','_','R','_'}};
    EXPECT_EQUAL(scoreBoard(board, sharedLexicon()), 1);
}

PROVIDED_TEST("Test scoreBoard, alternate paths for same word, still score of 1") {
    Grid<char> board = {{'C','C','_','_'},
                        {'C','Z','C','_'},
                        {'_','A','_','_'},
                        {'R','_','R','_'}};
    EXPECT_EQUAL(scoreBoard(board, sharedLexicon()), 1);
}

PROVIDED_TEST("Test scoreBoard, small number of words in corner of board") {
    Grid<char> board = {{'L','I','_','_'},
                        {'M','E','_','_'},
                        {'_','S','_','_'},
                        {'_','_','_','_'}};
    Set<string> words = {"SMILE", "LIMES", "MILES", "MILE", "MIES", "LIME", "LIES", "ELMS", "SEMI"};

    EXPECT_EQUAL(scoreBoard(board, sharedLexicon()),  2 + 2 + 2 + 1 + 1 + 1 + 1 + 1 + 1);
}

PROVIDED_TEST("Test scoreBoard, full board, small number of words") {
    Grid<char> board = {{'E','Z','R','R'},
                        {'O','H','I','O'},
                        {'N','J','I','H'},
                        {'Y','A','H','O'}};
    Set<string> words = { "HORIZON", "OHIA", "ORZO", "JOHN", "HAJI"};

    EXPECT_EQUAL(scoreBoard(board, sharedLexicon()), 4 + 1 + 1 + 1 + 1);
}

PROVIDED_TEST("Test scoreBoard, full board, medium number of words") {
    Grid<char> board = {{'O','T','H','X'},
                        {'T','H','T','P'},
                        {'S','S','F','E'},
                        {'N','A','L','T'}};

    EXPECT_EQUAL(scoreBoard(board, sharedLexicon()), 76);
}

PROVIDED_TEST("Test scoreBoard, full board, large number of words") {
    Grid<char> board = {{'E','A','A','R'},
                        {'L','V','T','S'},
                        {'R','A','A','N'},
                        {'O','I','S','E'}};

    EXPECT_EQUAL(scoreBoard(board, sharedLexicon()), 234);
}

STUDENT_TEST("test generate neighbors"){
    Grid<char> board(2, 2);
    GridLocation current(0, 0);
    Set<GridLocation> visited;
    Set<GridLocation> neighbors = generateNeighbors(board, current, visited);
    Set<GridLocation> expected = {GridLocation(0, 1), GridLocation(1, 1), GridLocation(1, 0)};
    EXPECT_EQUAL(neighbors, expected);
}

STUDENT_TEST("test generate neighbors"){
    Grid<char> board(3, 3);
    GridLocation current(1, 0);
    Set<GridLocation> visited = {GridLocation(0, 0), GridLocation(2, 1)};
    Set<GridLocation> neighbors = generateNeighbors(board, current, visited);
    Set<GridLocation> expected = {GridLocation(0, 1), GridLocation(1, 1), GridLocation(2, 0)};
    EXPECT_EQUAL(neighbors, expected);
}

STUDENT_TEST("Test scoreBoardHelper, board with one word") {
    Grid<char> board = {{'_','A','_','_'},
                        {'_','P','P','S'},
                        {'_','_','_','E'},
                        {'_','_','_','_'}};
    string word = "";
    GridLocation currentLocation(0, 1); //starting from A, find two words, APSE, APES
    Set<string> allWords;
    Set<GridLocation> visited;
    Lexicon lex = sharedLexicon();
    EXPECT_EQUAL(scoreBoardHelper(board, lex, currentLocation, word, allWords, visited ), 2);
}

STUDENT_TEST("Test scoreBoardHelper, board with two paths to same word") {
    Grid<char> board = {{'C','B','E','_'},
                        {'_','A','P','_'},
                        {'_','_','X','E'},
                        {'_','_','_','_'}};
    string word = "";
    GridLocation currentLocation(0, 0); //starting from C, we find "Cape"
    Set<string> allWords;
    Set<GridLocation> visited;
    Lexicon lex = sharedLexicon();

    EXPECT_EQUAL(scoreBoardHelper(board, lex, currentLocation, word, allWords, visited), 1);
}

STUDENT_TEST("Test scoreBoard, board with two words") {
    Grid<char> board = {{'_','A','_','_'},
                        {'_','P','P','L'},
                        {'_','_','_','E'},
                        {'_','_','_','_'}};
    //the two words are "Apple" and "Appel"
    EXPECT_EQUAL(scoreBoard(board, sharedLexicon()), 2 + 2);
}

STUDENT_TEST("Test scoreBoard, board with two words in the corners") {
    Grid<char> board = {{'K','_','_','_'},
                        {'C','_','_','_'},
                        {'A','_','C','A'},
                        {'R','_','L','L'}};
    //the two words are "RACK" and "CALL"
    EXPECT_EQUAL(scoreBoard(board, sharedLexicon()), 1 + 1);
}

